# -*- Ruby -*-
#
# ****  Code generated by the R2CORBA IDL Compiler ****
# R2CORBA has been developed by:
#        Remedy IT
#        Nijkerk, GLD
#        The Netherlands
#        http://www.remedy.nl  http://www.theaceorb.nl
#

module R2CORBA

  CORBA.implement('tao/Messaging/TAO_Ext.pidl', {}, CORBA::IDL::CLIENT_STUB) {

  ## include
  CORBA.implement('tao/TimeBase.pidl', {}, CORBA::IDL::CLIENT_STUB) {

  module TimeBase

    class TimeT < CORBA::_tc_ulonglong.get_type
      def TimeT._tc; @@tc_TimeT ||= CORBA::TypeCode::Alias.new('IDL:omg.org/TimeBase/TimeT:1.0', 'TimeT', self, CORBA::_tc_ulonglong); end
    end # typedef TimeT
    class InaccuracyT < TimeBase::TimeT
      def InaccuracyT._tc; @@tc_InaccuracyT ||= CORBA::TypeCode::Alias.new('IDL:omg.org/TimeBase/InaccuracyT:1.0', 'InaccuracyT', self,TimeBase::TimeT._tc); end
    end # typedef InaccuracyT
    class TdfT < CORBA::_tc_short.get_type
      def TdfT._tc; @@tc_TdfT ||= CORBA::TypeCode::Alias.new('IDL:omg.org/TimeBase/TdfT:1.0', 'TdfT', self, CORBA::_tc_short); end
    end # typedef TdfT

    class UtcT < CORBA::Portable::Struct

      def UtcT._tc
        @@tc_UtcT ||= CORBA::TypeCode::Struct.new('IDL:omg.org/TimeBase/UtcT:1.0'.freeze, 'UtcT', self,
           [['time', TimeBase::TimeT._tc],
            ['inacclo', CORBA._tc_ulong],
            ['inacchi', CORBA._tc_ushort],
            ['tdf', TimeBase::TdfT._tc]])
      end
      self._tc  # register typecode
      attr_accessor :time
      attr_accessor :inacclo
      attr_accessor :inacchi
      attr_accessor :tdf
      def initialize(*param_)
        @time,
        @inacclo,
        @inacchi,
        @tdf = param_
      end

    end #of struct UtcT

    class IntervalT < CORBA::Portable::Struct

      def IntervalT._tc
        @@tc_IntervalT ||= CORBA::TypeCode::Struct.new('IDL:omg.org/TimeBase/IntervalT:1.0'.freeze, 'IntervalT', self,
           [['lower_bound', TimeBase::TimeT._tc],
            ['upper_bound', TimeBase::TimeT._tc]])
      end
      self._tc  # register typecode
      attr_accessor :lower_bound
      attr_accessor :upper_bound
      def initialize(*param_)
        @lower_bound,
        @upper_bound = param_
      end

    end #of struct IntervalT
  end #of module TimeBase


  } ## end of include 'tao/TimeBase.pidl'

  module TAO

    CONNECTION_TIMEOUT_POLICY_TYPE = 1413545992

    module ConnectionTimeoutPolicy  ## interface

      include CORBA::Policy

      Id = 'IDL:tao/TAO/ConnectionTimeoutPolicy:1.0'.freeze
      Ids = [ Id,
              CORBA::Policy::Id ].freeze

      def ConnectionTimeoutPolicy._tc; @@tc_ConnectionTimeoutPolicy ||= CORBA::TypeCode::ObjectRef.new(Id, 'ConnectionTimeoutPolicy', self); end
      self._tc  # register typecode

      def ConnectionTimeoutPolicy._narrow(obj)
        return CORBA::Stub.create_stub(obj)._unchecked_narrow!(self)
      end

      def ConnectionTimeoutPolicy._duplicate(obj)
        obj
      end

      def _interface_repository_id
        self.class::Id
      end


      def relative_expiry()
        raise ::CORBA::NO_IMPLEMENT.new(
                 'unimplemented attribute on local interface',
                 1, ::CORBA::COMPLETED_NO)
      end #of attribute get_relative_expiry
    end #of interface ConnectionTimeoutPolicy
    class BufferingConstraintMode < CORBA::_tc_ushort.get_type
      def BufferingConstraintMode._tc; @@tc_BufferingConstraintMode ||= CORBA::TypeCode::Alias.new('IDL:tao/TAO/BufferingConstraintMode:1.0', 'BufferingConstraintMode', self, CORBA::_tc_ushort); end
    end # typedef BufferingConstraintMode
    BUFFER_FLUSH = 0
    BUFFER_TIMEOUT = 1
    BUFFER_MESSAGE_COUNT = 2
    BUFFER_MESSAGE_BYTES = 4

    class BufferingConstraint < CORBA::Portable::Struct

      def BufferingConstraint._tc
        @@tc_BufferingConstraint ||= CORBA::TypeCode::Struct.new('IDL:tao/TAO/BufferingConstraint:1.0'.freeze, 'BufferingConstraint', self,
           [['mode', TAO::BufferingConstraintMode._tc],
            ['timeout', TimeBase::TimeT._tc],
            ['message_count', CORBA._tc_ulong],
            ['message_bytes', CORBA._tc_ulong]])
      end
      self._tc  # register typecode
      attr_accessor :mode
      attr_accessor :timeout
      attr_accessor :message_count
      attr_accessor :message_bytes
      def initialize(*param_)
        @mode,
        @timeout,
        @message_count,
        @message_bytes = param_
      end

    end #of struct BufferingConstraint
    BUFFERING_CONSTRAINT_POLICY_TYPE = 1413545985

    module BufferingConstraintPolicy  ## interface

      include CORBA::Policy

      Id = 'IDL:tao/TAO/BufferingConstraintPolicy:1.0'.freeze
      Ids = [ Id,
              CORBA::Policy::Id ].freeze

      def BufferingConstraintPolicy._tc; @@tc_BufferingConstraintPolicy ||= CORBA::TypeCode::ObjectRef.new(Id, 'BufferingConstraintPolicy', self); end
      self._tc  # register typecode

      def BufferingConstraintPolicy._narrow(obj)
        return CORBA::Stub.create_stub(obj)._unchecked_narrow!(self)
      end

      def BufferingConstraintPolicy._duplicate(obj)
        obj
      end

      def _interface_repository_id
        self.class::Id
      end


      def buffering_constraint()
        raise ::CORBA::NO_IMPLEMENT.new(
                 'unimplemented attribute on local interface',
                 1, ::CORBA::COMPLETED_NO)
      end #of attribute get_buffering_constraint
    end #of interface BufferingConstraintPolicy
  end #of module TAO

  } ## end of 'tao/Messaging/TAO_Ext.pidl'
end #of module R2CORBA

# -*- END -*-
