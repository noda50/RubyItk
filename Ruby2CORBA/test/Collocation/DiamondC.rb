# -*- Ruby -*-
#
# ****  Code generated by the R2CORBA IDL Compiler ****
# R2CORBA has been developed by:
#        Remedy IT
#        Nijkerk, GLD
#        The Netherlands
#        http://www.remedy.nl  http://www.theaceorb.nl
#
require 'corba'

CORBA.implement('Diamond.idl', {}, CORBA::IDL::CLIENT_STUB) {

module Diamond


  module Top  ## interface


    Id = 'IDL:Diamond/Top:1.0'.freeze
    Ids = [ Id ].freeze

    def Top._tc; @@tc_Top ||= CORBA::TypeCode::ObjectRef.new(Id, 'Top', self); end
    self._tc  # register typecode

    def Top._narrow(obj)
      return CORBA::Stub.create_stub(obj)._narrow!(self)
    end

    def Top._duplicate(obj)
      return CORBA::Stub.create_stub(super(obj))._narrow!(self)
    end

    def _interface_repository_id
      self.class::Id
    end


    def shape()
      _ret = self._invoke('shape', {
        :result_type => CORBA._tc_string})
      _ret
    end #of operation shape
  end #of interface Top

  module Left  ## interface

    include Diamond::Top

    Id = 'IDL:Diamond/Left:1.0'.freeze
    Ids = [ Id,
            Diamond::Top::Id ].freeze

    def Left._tc; @@tc_Left ||= CORBA::TypeCode::ObjectRef.new(Id, 'Left', self); end
    self._tc  # register typecode

    def Left._narrow(obj)
      return CORBA::Stub.create_stub(obj)._narrow!(self)
    end

    def Left._duplicate(obj)
      return CORBA::Stub.create_stub(super(obj))._narrow!(self)
    end

    def _interface_repository_id
      self.class::Id
    end


    def color()
      _ret = self._invoke('color', {
        :result_type => CORBA._tc_string})
      _ret
    end #of operation color
  end #of interface Left

  module Right  ## interface

    include Diamond::Top

    Id = 'IDL:Diamond/Right:1.0'.freeze
    Ids = [ Id,
            Diamond::Top::Id ].freeze

    def Right._tc; @@tc_Right ||= CORBA::TypeCode::ObjectRef.new(Id, 'Right', self); end
    self._tc  # register typecode

    def Right._narrow(obj)
      return CORBA::Stub.create_stub(obj)._narrow!(self)
    end

    def Right._duplicate(obj)
      return CORBA::Stub.create_stub(super(obj))._narrow!(self)
    end

    def _interface_repository_id
      self.class::Id
    end


    def width()
      _ret = self._invoke('width', {
        :result_type => CORBA._tc_long})
      _ret
    end #of operation width
  end #of interface Right

  module Buttom  ## interface

    include Diamond::Left
    include Diamond::Right

    Id = 'IDL:Diamond/Buttom:1.0'.freeze
    Ids = [ Id,
            Diamond::Left::Id,
            Diamond::Right::Id ].freeze

    def Buttom._tc; @@tc_Buttom ||= CORBA::TypeCode::ObjectRef.new(Id, 'Buttom', self); end
    self._tc  # register typecode

    def Buttom._narrow(obj)
      return CORBA::Stub.create_stub(obj)._narrow!(self)
    end

    def Buttom._duplicate(obj)
      return CORBA::Stub.create_stub(super(obj))._narrow!(self)
    end

    def _interface_repository_id
      self.class::Id
    end

    class E_units < ::Fixnum
      def E_units._tc
        @@tc_E_units ||= CORBA::TypeCode::Enum.new('IDL:Diamond/Buttom/e_units:1.0'.freeze, 'E_units', [
            'MM',
            'CM'])
      end
      self._tc  # register typecode
    end # enum E_units
    MM = 0
    CM = 1

    def name()
      _ret = self._invoke('name', {
        :result_type => CORBA._tc_string})
      _ret
    end #of operation name

    def area(unit)
      unit = Diamond::Buttom::E_units._tc.validate(unit)
      _ret = self._invoke('area', {
        :arg_list => [
          ['unit', CORBA::ARG_IN, Diamond::Buttom::E_units._tc, unit],
          ['result', CORBA::ARG_OUT, CORBA._tc_long]],
        :result_type => CORBA._tc_void})
      _ret
    end #of operation area
  end #of interface Buttom
end #of module Diamond

} ## end of 'Diamond.idl'
# -*- END -*-
